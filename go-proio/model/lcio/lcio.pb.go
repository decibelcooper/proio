// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proio/model/lcio.proto

package lcio // import "github.com/decibelcooper/proio/go-proio/model/lcio"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type IntParams struct {
	Array                []int32  `protobuf:"varint,1,rep,packed,name=array" json:"array,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IntParams) Reset()         { *m = IntParams{} }
func (m *IntParams) String() string { return proto.CompactTextString(m) }
func (*IntParams) ProtoMessage()    {}
func (*IntParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{0}
}
func (m *IntParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IntParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntParams.Merge(dst, src)
}
func (m *IntParams) XXX_Size() int {
	return m.Size()
}
func (m *IntParams) XXX_DiscardUnknown() {
	xxx_messageInfo_IntParams.DiscardUnknown(m)
}

var xxx_messageInfo_IntParams proto.InternalMessageInfo

func (m *IntParams) GetArray() []int32 {
	if m != nil {
		return m.Array
	}
	return nil
}

type FloatParams struct {
	Array                []float32 `protobuf:"fixed32,1,rep,packed,name=array" json:"array,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FloatParams) Reset()         { *m = FloatParams{} }
func (m *FloatParams) String() string { return proto.CompactTextString(m) }
func (*FloatParams) ProtoMessage()    {}
func (*FloatParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{1}
}
func (m *FloatParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FloatParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FloatParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FloatParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatParams.Merge(dst, src)
}
func (m *FloatParams) XXX_Size() int {
	return m.Size()
}
func (m *FloatParams) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatParams.DiscardUnknown(m)
}

var xxx_messageInfo_FloatParams proto.InternalMessageInfo

func (m *FloatParams) GetArray() []float32 {
	if m != nil {
		return m.Array
	}
	return nil
}

type StringParams struct {
	Array                []string `protobuf:"bytes,1,rep,name=array" json:"array,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StringParams) Reset()         { *m = StringParams{} }
func (m *StringParams) String() string { return proto.CompactTextString(m) }
func (*StringParams) ProtoMessage()    {}
func (*StringParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{2}
}
func (m *StringParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StringParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringParams.Merge(dst, src)
}
func (m *StringParams) XXX_Size() int {
	return m.Size()
}
func (m *StringParams) XXX_DiscardUnknown() {
	xxx_messageInfo_StringParams.DiscardUnknown(m)
}

var xxx_messageInfo_StringParams proto.InternalMessageInfo

func (m *StringParams) GetArray() []string {
	if m != nil {
		return m.Array
	}
	return nil
}

type Params struct {
	Ints                 map[string]*IntParams    `protobuf:"bytes,1,rep,name=ints" json:"ints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Floats               map[string]*FloatParams  `protobuf:"bytes,2,rep,name=floats" json:"floats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Strings              map[string]*StringParams `protobuf:"bytes,3,rep,name=strings" json:"strings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{3}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(dst, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetInts() map[string]*IntParams {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *Params) GetFloats() map[string]*FloatParams {
	if m != nil {
		return m.Floats
	}
	return nil
}

func (m *Params) GetStrings() map[string]*StringParams {
	if m != nil {
		return m.Strings
	}
	return nil
}

type ParticleID struct {
	Likelihood           float32   `protobuf:"fixed32,1,opt,name=likelihood,proto3" json:"likelihood,omitempty"`
	Type                 int32     `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	PDG                  int32     `protobuf:"varint,3,opt,name=PDG,proto3" json:"PDG,omitempty"`
	AlgType              int32     `protobuf:"varint,4,opt,name=algType,proto3" json:"algType,omitempty"`
	Params               []float32 `protobuf:"fixed32,5,rep,packed,name=params" json:"params,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ParticleID) Reset()         { *m = ParticleID{} }
func (m *ParticleID) String() string { return proto.CompactTextString(m) }
func (*ParticleID) ProtoMessage()    {}
func (*ParticleID) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{4}
}
func (m *ParticleID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParticleID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParticleID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ParticleID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParticleID.Merge(dst, src)
}
func (m *ParticleID) XXX_Size() int {
	return m.Size()
}
func (m *ParticleID) XXX_DiscardUnknown() {
	xxx_messageInfo_ParticleID.DiscardUnknown(m)
}

var xxx_messageInfo_ParticleID proto.InternalMessageInfo

func (m *ParticleID) GetLikelihood() float32 {
	if m != nil {
		return m.Likelihood
	}
	return 0
}

func (m *ParticleID) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ParticleID) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *ParticleID) GetAlgType() int32 {
	if m != nil {
		return m.AlgType
	}
	return 0
}

func (m *ParticleID) GetParams() []float32 {
	if m != nil {
		return m.Params
	}
	return nil
}

type MCParticle struct {
	Parents              []uint64  `protobuf:"varint,1,rep,packed,name=parents" json:"parents,omitempty"`
	Children             []uint64  `protobuf:"varint,2,rep,packed,name=children" json:"children,omitempty"`
	PDG                  int32     `protobuf:"varint,3,opt,name=PDG,proto3" json:"PDG,omitempty"`
	Vertex               []float64 `protobuf:"fixed64,4,rep,packed,name=vertex" json:"vertex,omitempty"`
	Time                 float32   `protobuf:"fixed32,5,opt,name=time,proto3" json:"time,omitempty"`
	P                    []float64 `protobuf:"fixed64,6,rep,packed,name=p" json:"p,omitempty"`
	Mass                 float64   `protobuf:"fixed64,7,opt,name=mass,proto3" json:"mass,omitempty"`
	Charge               float32   `protobuf:"fixed32,8,opt,name=charge,proto3" json:"charge,omitempty"`
	PEndPoint            []float64 `protobuf:"fixed64,9,rep,packed,name=PEndPoint" json:"PEndPoint,omitempty"`
	Spin                 []float32 `protobuf:"fixed32,10,rep,packed,name=spin" json:"spin,omitempty"`
	ColorFlow            []int32   `protobuf:"varint,11,rep,packed,name=colorFlow" json:"colorFlow,omitempty"`
	GenStatus            int32     `protobuf:"varint,12,opt,name=genStatus,proto3" json:"genStatus,omitempty"`
	SimStatus            uint32    `protobuf:"varint,13,opt,name=simStatus,proto3" json:"simStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *MCParticle) Reset()         { *m = MCParticle{} }
func (m *MCParticle) String() string { return proto.CompactTextString(m) }
func (*MCParticle) ProtoMessage()    {}
func (*MCParticle) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{5}
}
func (m *MCParticle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MCParticle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MCParticle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MCParticle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MCParticle.Merge(dst, src)
}
func (m *MCParticle) XXX_Size() int {
	return m.Size()
}
func (m *MCParticle) XXX_DiscardUnknown() {
	xxx_messageInfo_MCParticle.DiscardUnknown(m)
}

var xxx_messageInfo_MCParticle proto.InternalMessageInfo

func (m *MCParticle) GetParents() []uint64 {
	if m != nil {
		return m.Parents
	}
	return nil
}

func (m *MCParticle) GetChildren() []uint64 {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *MCParticle) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *MCParticle) GetVertex() []float64 {
	if m != nil {
		return m.Vertex
	}
	return nil
}

func (m *MCParticle) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *MCParticle) GetP() []float64 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *MCParticle) GetMass() float64 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *MCParticle) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *MCParticle) GetPEndPoint() []float64 {
	if m != nil {
		return m.PEndPoint
	}
	return nil
}

func (m *MCParticle) GetSpin() []float32 {
	if m != nil {
		return m.Spin
	}
	return nil
}

func (m *MCParticle) GetColorFlow() []int32 {
	if m != nil {
		return m.ColorFlow
	}
	return nil
}

func (m *MCParticle) GetGenStatus() int32 {
	if m != nil {
		return m.GenStatus
	}
	return 0
}

func (m *MCParticle) GetSimStatus() uint32 {
	if m != nil {
		return m.SimStatus
	}
	return 0
}

type SimTrackerHit struct {
	CellID0              int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1              int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Pos                  []float64 `protobuf:"fixed64,3,rep,packed,name=pos" json:"pos,omitempty"`
	EDep                 float32   `protobuf:"fixed32,4,opt,name=EDep,proto3" json:"EDep,omitempty"`
	Time                 float32   `protobuf:"fixed32,5,opt,name=time,proto3" json:"time,omitempty"`
	Mc                   uint64    `protobuf:"varint,6,opt,name=mc,proto3" json:"mc,omitempty"`
	P                    []float32 `protobuf:"fixed32,7,rep,packed,name=p" json:"p,omitempty"`
	PathLength           float32   `protobuf:"fixed32,8,opt,name=pathLength,proto3" json:"pathLength,omitempty"`
	Quality              int32     `protobuf:"varint,9,opt,name=quality,proto3" json:"quality,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SimTrackerHit) Reset()         { *m = SimTrackerHit{} }
func (m *SimTrackerHit) String() string { return proto.CompactTextString(m) }
func (*SimTrackerHit) ProtoMessage()    {}
func (*SimTrackerHit) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{6}
}
func (m *SimTrackerHit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimTrackerHit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimTrackerHit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SimTrackerHit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimTrackerHit.Merge(dst, src)
}
func (m *SimTrackerHit) XXX_Size() int {
	return m.Size()
}
func (m *SimTrackerHit) XXX_DiscardUnknown() {
	xxx_messageInfo_SimTrackerHit.DiscardUnknown(m)
}

var xxx_messageInfo_SimTrackerHit proto.InternalMessageInfo

func (m *SimTrackerHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *SimTrackerHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *SimTrackerHit) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *SimTrackerHit) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *SimTrackerHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SimTrackerHit) GetMc() uint64 {
	if m != nil {
		return m.Mc
	}
	return 0
}

func (m *SimTrackerHit) GetP() []float32 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *SimTrackerHit) GetPathLength() float32 {
	if m != nil {
		return m.PathLength
	}
	return 0
}

func (m *SimTrackerHit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

type TrackerRawData struct {
	CellID0              int32    `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1              int32    `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time                 int32    `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
	ADCs                 []uint32 `protobuf:"varint,4,rep,packed,name=ADCs" json:"ADCs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TrackerRawData) Reset()         { *m = TrackerRawData{} }
func (m *TrackerRawData) String() string { return proto.CompactTextString(m) }
func (*TrackerRawData) ProtoMessage()    {}
func (*TrackerRawData) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{7}
}
func (m *TrackerRawData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackerRawData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackerRawData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TrackerRawData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackerRawData.Merge(dst, src)
}
func (m *TrackerRawData) XXX_Size() int {
	return m.Size()
}
func (m *TrackerRawData) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackerRawData.DiscardUnknown(m)
}

var xxx_messageInfo_TrackerRawData proto.InternalMessageInfo

func (m *TrackerRawData) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerRawData) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerRawData) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerRawData) GetADCs() []uint32 {
	if m != nil {
		return m.ADCs
	}
	return nil
}

type TrackerData struct {
	CellID0              int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1              int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time                 float32   `protobuf:"fixed32,3,opt,name=time,proto3" json:"time,omitempty"`
	Charges              []float32 `protobuf:"fixed32,4,rep,packed,name=charges" json:"charges,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TrackerData) Reset()         { *m = TrackerData{} }
func (m *TrackerData) String() string { return proto.CompactTextString(m) }
func (*TrackerData) ProtoMessage()    {}
func (*TrackerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{8}
}
func (m *TrackerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackerData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TrackerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackerData.Merge(dst, src)
}
func (m *TrackerData) XXX_Size() int {
	return m.Size()
}
func (m *TrackerData) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackerData.DiscardUnknown(m)
}

var xxx_messageInfo_TrackerData proto.InternalMessageInfo

func (m *TrackerData) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerData) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerData) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerData) GetCharges() []float32 {
	if m != nil {
		return m.Charges
	}
	return nil
}

type TrackerHit struct {
	CellID0              int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1              int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type                 int32     `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Pos                  []float64 `protobuf:"fixed64,4,rep,packed,name=pos" json:"pos,omitempty"`
	Cov                  []float64 `protobuf:"fixed64,5,rep,packed,name=cov" json:"cov,omitempty"`
	EDep                 float32   `protobuf:"fixed32,6,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr              float32   `protobuf:"fixed32,7,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time                 float32   `protobuf:"fixed32,8,opt,name=time,proto3" json:"time,omitempty"`
	Quality              int32     `protobuf:"varint,9,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits              []uint64  `protobuf:"varint,10,rep,packed,name=rawHits" json:"rawHits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TrackerHit) Reset()         { *m = TrackerHit{} }
func (m *TrackerHit) String() string { return proto.CompactTextString(m) }
func (*TrackerHit) ProtoMessage()    {}
func (*TrackerHit) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{9}
}
func (m *TrackerHit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackerHit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackerHit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TrackerHit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackerHit.Merge(dst, src)
}
func (m *TrackerHit) XXX_Size() int {
	return m.Size()
}
func (m *TrackerHit) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackerHit.DiscardUnknown(m)
}

var xxx_messageInfo_TrackerHit proto.InternalMessageInfo

func (m *TrackerHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHit) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHit) GetCov() []float64 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *TrackerHit) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHit) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHit) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHit) GetRawHits() []uint64 {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerPulse struct {
	CellID0              int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1              int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Time                 float32   `protobuf:"fixed32,3,opt,name=time,proto3" json:"time,omitempty"`
	Charge               float32   `protobuf:"fixed32,4,opt,name=charge,proto3" json:"charge,omitempty"`
	Cov                  []float32 `protobuf:"fixed32,5,rep,packed,name=cov" json:"cov,omitempty"`
	Quality              int32     `protobuf:"varint,6,opt,name=quality,proto3" json:"quality,omitempty"`
	TPC                  uint64    `protobuf:"varint,7,opt,name=TPC,proto3" json:"TPC,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TrackerPulse) Reset()         { *m = TrackerPulse{} }
func (m *TrackerPulse) String() string { return proto.CompactTextString(m) }
func (*TrackerPulse) ProtoMessage()    {}
func (*TrackerPulse) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{10}
}
func (m *TrackerPulse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackerPulse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackerPulse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TrackerPulse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackerPulse.Merge(dst, src)
}
func (m *TrackerPulse) XXX_Size() int {
	return m.Size()
}
func (m *TrackerPulse) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackerPulse.DiscardUnknown(m)
}

var xxx_messageInfo_TrackerPulse proto.InternalMessageInfo

func (m *TrackerPulse) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerPulse) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerPulse) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerPulse) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *TrackerPulse) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *TrackerPulse) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerPulse) GetTPC() uint64 {
	if m != nil {
		return m.TPC
	}
	return 0
}

type TrackerHitPlane struct {
	CellID0              int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1              int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type                 int32     `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Pos                  []float64 `protobuf:"fixed64,4,rep,packed,name=pos" json:"pos,omitempty"`
	U                    []float32 `protobuf:"fixed32,5,rep,packed,name=U" json:"U,omitempty"`
	V                    []float32 `protobuf:"fixed32,6,rep,packed,name=V" json:"V,omitempty"`
	DU                   float32   `protobuf:"fixed32,7,opt,name=dU,proto3" json:"dU,omitempty"`
	DV                   float32   `protobuf:"fixed32,8,opt,name=dV,proto3" json:"dV,omitempty"`
	EDep                 float32   `protobuf:"fixed32,9,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr              float32   `protobuf:"fixed32,10,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time                 float32   `protobuf:"fixed32,11,opt,name=time,proto3" json:"time,omitempty"`
	Quality              int32     `protobuf:"varint,12,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits              []uint64  `protobuf:"varint,13,rep,packed,name=rawHits" json:"rawHits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TrackerHitPlane) Reset()         { *m = TrackerHitPlane{} }
func (m *TrackerHitPlane) String() string { return proto.CompactTextString(m) }
func (*TrackerHitPlane) ProtoMessage()    {}
func (*TrackerHitPlane) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{11}
}
func (m *TrackerHitPlane) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackerHitPlane) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackerHitPlane.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TrackerHitPlane) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackerHitPlane.Merge(dst, src)
}
func (m *TrackerHitPlane) XXX_Size() int {
	return m.Size()
}
func (m *TrackerHitPlane) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackerHitPlane.DiscardUnknown(m)
}

var xxx_messageInfo_TrackerHitPlane proto.InternalMessageInfo

func (m *TrackerHitPlane) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHitPlane) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHitPlane) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHitPlane) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHitPlane) GetU() []float32 {
	if m != nil {
		return m.U
	}
	return nil
}

func (m *TrackerHitPlane) GetV() []float32 {
	if m != nil {
		return m.V
	}
	return nil
}

func (m *TrackerHitPlane) GetDU() float32 {
	if m != nil {
		return m.DU
	}
	return 0
}

func (m *TrackerHitPlane) GetDV() float32 {
	if m != nil {
		return m.DV
	}
	return 0
}

func (m *TrackerHitPlane) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHitPlane) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHitPlane) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHitPlane) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHitPlane) GetRawHits() []uint64 {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type TrackerHitZCylinder struct {
	CellID0              int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1              int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Type                 int32     `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Pos                  []float64 `protobuf:"fixed64,4,rep,packed,name=pos" json:"pos,omitempty"`
	Center               []float32 `protobuf:"fixed32,5,rep,packed,name=center" json:"center,omitempty"`
	DRPhi                float32   `protobuf:"fixed32,6,opt,name=dRPhi,proto3" json:"dRPhi,omitempty"`
	DZ                   float32   `protobuf:"fixed32,7,opt,name=dZ,proto3" json:"dZ,omitempty"`
	EDep                 float32   `protobuf:"fixed32,8,opt,name=EDep,proto3" json:"EDep,omitempty"`
	EDepErr              float32   `protobuf:"fixed32,9,opt,name=EDepErr,proto3" json:"EDepErr,omitempty"`
	Time                 float32   `protobuf:"fixed32,10,opt,name=time,proto3" json:"time,omitempty"`
	Quality              int32     `protobuf:"varint,11,opt,name=quality,proto3" json:"quality,omitempty"`
	RawHits              []uint64  `protobuf:"varint,12,rep,packed,name=rawHits" json:"rawHits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TrackerHitZCylinder) Reset()         { *m = TrackerHitZCylinder{} }
func (m *TrackerHitZCylinder) String() string { return proto.CompactTextString(m) }
func (*TrackerHitZCylinder) ProtoMessage()    {}
func (*TrackerHitZCylinder) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{12}
}
func (m *TrackerHitZCylinder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrackerHitZCylinder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrackerHitZCylinder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TrackerHitZCylinder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrackerHitZCylinder.Merge(dst, src)
}
func (m *TrackerHitZCylinder) XXX_Size() int {
	return m.Size()
}
func (m *TrackerHitZCylinder) XXX_DiscardUnknown() {
	xxx_messageInfo_TrackerHitZCylinder.DiscardUnknown(m)
}

var xxx_messageInfo_TrackerHitZCylinder proto.InternalMessageInfo

func (m *TrackerHitZCylinder) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *TrackerHitZCylinder) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *TrackerHitZCylinder) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TrackerHitZCylinder) GetPos() []float64 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *TrackerHitZCylinder) GetCenter() []float32 {
	if m != nil {
		return m.Center
	}
	return nil
}

func (m *TrackerHitZCylinder) GetDRPhi() float32 {
	if m != nil {
		return m.DRPhi
	}
	return 0
}

func (m *TrackerHitZCylinder) GetDZ() float32 {
	if m != nil {
		return m.DZ
	}
	return 0
}

func (m *TrackerHitZCylinder) GetEDep() float32 {
	if m != nil {
		return m.EDep
	}
	return 0
}

func (m *TrackerHitZCylinder) GetEDepErr() float32 {
	if m != nil {
		return m.EDepErr
	}
	return 0
}

func (m *TrackerHitZCylinder) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TrackerHitZCylinder) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *TrackerHitZCylinder) GetRawHits() []uint64 {
	if m != nil {
		return m.RawHits
	}
	return nil
}

type Track struct {
	Type                 int32               `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Chi2                 float32             `protobuf:"fixed32,2,opt,name=chi2,proto3" json:"chi2,omitempty"`
	NDF                  int32               `protobuf:"varint,3,opt,name=NDF,proto3" json:"NDF,omitempty"`
	DEdx                 float32             `protobuf:"fixed32,4,opt,name=dEdx,proto3" json:"dEdx,omitempty"`
	DEdxErr              float32             `protobuf:"fixed32,5,opt,name=dEdxErr,proto3" json:"dEdxErr,omitempty"`
	Radius               float32             `protobuf:"fixed32,6,opt,name=radius,proto3" json:"radius,omitempty"`
	SubDetHits           []int32             `protobuf:"varint,7,rep,packed,name=subDetHits" json:"subDetHits,omitempty"`
	States               []*Track_TrackState `protobuf:"bytes,8,rep,name=states" json:"states,omitempty"`
	Hits                 []uint64            `protobuf:"varint,9,rep,packed,name=hits" json:"hits,omitempty"`
	Tracks               []uint64            `protobuf:"varint,10,rep,packed,name=tracks" json:"tracks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Track) Reset()         { *m = Track{} }
func (m *Track) String() string { return proto.CompactTextString(m) }
func (*Track) ProtoMessage()    {}
func (*Track) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{13}
}
func (m *Track) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Track) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Track.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Track) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Track.Merge(dst, src)
}
func (m *Track) XXX_Size() int {
	return m.Size()
}
func (m *Track) XXX_DiscardUnknown() {
	xxx_messageInfo_Track.DiscardUnknown(m)
}

var xxx_messageInfo_Track proto.InternalMessageInfo

func (m *Track) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Track) GetChi2() float32 {
	if m != nil {
		return m.Chi2
	}
	return 0
}

func (m *Track) GetNDF() int32 {
	if m != nil {
		return m.NDF
	}
	return 0
}

func (m *Track) GetDEdx() float32 {
	if m != nil {
		return m.DEdx
	}
	return 0
}

func (m *Track) GetDEdxErr() float32 {
	if m != nil {
		return m.DEdxErr
	}
	return 0
}

func (m *Track) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *Track) GetSubDetHits() []int32 {
	if m != nil {
		return m.SubDetHits
	}
	return nil
}

func (m *Track) GetStates() []*Track_TrackState {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *Track) GetHits() []uint64 {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *Track) GetTracks() []uint64 {
	if m != nil {
		return m.Tracks
	}
	return nil
}

type Track_TrackState struct {
	Loc                  int32     `protobuf:"varint,1,opt,name=loc,proto3" json:"loc,omitempty"`
	D0                   float32   `protobuf:"fixed32,2,opt,name=d0,proto3" json:"d0,omitempty"`
	Phi                  float32   `protobuf:"fixed32,3,opt,name=phi,proto3" json:"phi,omitempty"`
	Omega                float32   `protobuf:"fixed32,4,opt,name=omega,proto3" json:"omega,omitempty"`
	Z0                   float32   `protobuf:"fixed32,5,opt,name=z0,proto3" json:"z0,omitempty"`
	TanL                 float32   `protobuf:"fixed32,6,opt,name=tanL,proto3" json:"tanL,omitempty"`
	Cov                  []float32 `protobuf:"fixed32,7,rep,packed,name=cov" json:"cov,omitempty"`
	Ref                  []float32 `protobuf:"fixed32,8,rep,packed,name=ref" json:"ref,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Track_TrackState) Reset()         { *m = Track_TrackState{} }
func (m *Track_TrackState) String() string { return proto.CompactTextString(m) }
func (*Track_TrackState) ProtoMessage()    {}
func (*Track_TrackState) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{13, 0}
}
func (m *Track_TrackState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Track_TrackState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Track_TrackState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Track_TrackState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Track_TrackState.Merge(dst, src)
}
func (m *Track_TrackState) XXX_Size() int {
	return m.Size()
}
func (m *Track_TrackState) XXX_DiscardUnknown() {
	xxx_messageInfo_Track_TrackState.DiscardUnknown(m)
}

var xxx_messageInfo_Track_TrackState proto.InternalMessageInfo

func (m *Track_TrackState) GetLoc() int32 {
	if m != nil {
		return m.Loc
	}
	return 0
}

func (m *Track_TrackState) GetD0() float32 {
	if m != nil {
		return m.D0
	}
	return 0
}

func (m *Track_TrackState) GetPhi() float32 {
	if m != nil {
		return m.Phi
	}
	return 0
}

func (m *Track_TrackState) GetOmega() float32 {
	if m != nil {
		return m.Omega
	}
	return 0
}

func (m *Track_TrackState) GetZ0() float32 {
	if m != nil {
		return m.Z0
	}
	return 0
}

func (m *Track_TrackState) GetTanL() float32 {
	if m != nil {
		return m.TanL
	}
	return 0
}

func (m *Track_TrackState) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *Track_TrackState) GetRef() []float32 {
	if m != nil {
		return m.Ref
	}
	return nil
}

type SimCalorimeterHit struct {
	CellID0              int32                        `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1              int32                        `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Energy               float32                      `protobuf:"fixed32,3,opt,name=energy,proto3" json:"energy,omitempty"`
	Pos                  []float32                    `protobuf:"fixed32,4,rep,packed,name=pos" json:"pos,omitempty"`
	Contributions        []*SimCalorimeterHit_Contrib `protobuf:"bytes,5,rep,name=contributions" json:"contributions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *SimCalorimeterHit) Reset()         { *m = SimCalorimeterHit{} }
func (m *SimCalorimeterHit) String() string { return proto.CompactTextString(m) }
func (*SimCalorimeterHit) ProtoMessage()    {}
func (*SimCalorimeterHit) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{14}
}
func (m *SimCalorimeterHit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimCalorimeterHit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimCalorimeterHit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SimCalorimeterHit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimCalorimeterHit.Merge(dst, src)
}
func (m *SimCalorimeterHit) XXX_Size() int {
	return m.Size()
}
func (m *SimCalorimeterHit) XXX_DiscardUnknown() {
	xxx_messageInfo_SimCalorimeterHit.DiscardUnknown(m)
}

var xxx_messageInfo_SimCalorimeterHit proto.InternalMessageInfo

func (m *SimCalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *SimCalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *SimCalorimeterHit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *SimCalorimeterHit) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *SimCalorimeterHit) GetContributions() []*SimCalorimeterHit_Contrib {
	if m != nil {
		return m.Contributions
	}
	return nil
}

type SimCalorimeterHit_Contrib struct {
	MCParticle           uint64    `protobuf:"varint,1,opt,name=MCParticle,proto3" json:"MCParticle,omitempty"`
	Energy               float32   `protobuf:"fixed32,2,opt,name=energy,proto3" json:"energy,omitempty"`
	Time                 float32   `protobuf:"fixed32,3,opt,name=time,proto3" json:"time,omitempty"`
	PDG                  int32     `protobuf:"varint,4,opt,name=PDG,proto3" json:"PDG,omitempty"`
	StepPos              []float32 `protobuf:"fixed32,5,rep,packed,name=stepPos" json:"stepPos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SimCalorimeterHit_Contrib) Reset()         { *m = SimCalorimeterHit_Contrib{} }
func (m *SimCalorimeterHit_Contrib) String() string { return proto.CompactTextString(m) }
func (*SimCalorimeterHit_Contrib) ProtoMessage()    {}
func (*SimCalorimeterHit_Contrib) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{14, 0}
}
func (m *SimCalorimeterHit_Contrib) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimCalorimeterHit_Contrib) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimCalorimeterHit_Contrib.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SimCalorimeterHit_Contrib) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimCalorimeterHit_Contrib.Merge(dst, src)
}
func (m *SimCalorimeterHit_Contrib) XXX_Size() int {
	return m.Size()
}
func (m *SimCalorimeterHit_Contrib) XXX_DiscardUnknown() {
	xxx_messageInfo_SimCalorimeterHit_Contrib.DiscardUnknown(m)
}

var xxx_messageInfo_SimCalorimeterHit_Contrib proto.InternalMessageInfo

func (m *SimCalorimeterHit_Contrib) GetMCParticle() uint64 {
	if m != nil {
		return m.MCParticle
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetPDG() int32 {
	if m != nil {
		return m.PDG
	}
	return 0
}

func (m *SimCalorimeterHit_Contrib) GetStepPos() []float32 {
	if m != nil {
		return m.StepPos
	}
	return nil
}

type RawCalorimeterHit struct {
	CellID0              int32    `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1              int32    `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Amplitude            int32    `protobuf:"varint,3,opt,name=amplitude,proto3" json:"amplitude,omitempty"`
	TimeStamp            int32    `protobuf:"varint,4,opt,name=timeStamp,proto3" json:"timeStamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawCalorimeterHit) Reset()         { *m = RawCalorimeterHit{} }
func (m *RawCalorimeterHit) String() string { return proto.CompactTextString(m) }
func (*RawCalorimeterHit) ProtoMessage()    {}
func (*RawCalorimeterHit) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{15}
}
func (m *RawCalorimeterHit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawCalorimeterHit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawCalorimeterHit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RawCalorimeterHit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawCalorimeterHit.Merge(dst, src)
}
func (m *RawCalorimeterHit) XXX_Size() int {
	return m.Size()
}
func (m *RawCalorimeterHit) XXX_DiscardUnknown() {
	xxx_messageInfo_RawCalorimeterHit.DiscardUnknown(m)
}

var xxx_messageInfo_RawCalorimeterHit proto.InternalMessageInfo

func (m *RawCalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *RawCalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *RawCalorimeterHit) GetAmplitude() int32 {
	if m != nil {
		return m.Amplitude
	}
	return 0
}

func (m *RawCalorimeterHit) GetTimeStamp() int32 {
	if m != nil {
		return m.TimeStamp
	}
	return 0
}

type CalorimeterHit struct {
	CellID0              int32     `protobuf:"varint,1,opt,name=cellID0,proto3" json:"cellID0,omitempty"`
	CellID1              int32     `protobuf:"varint,2,opt,name=cellID1,proto3" json:"cellID1,omitempty"`
	Energy               float32   `protobuf:"fixed32,3,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyErr            float32   `protobuf:"fixed32,4,opt,name=energyErr,proto3" json:"energyErr,omitempty"`
	Time                 float32   `protobuf:"fixed32,5,opt,name=time,proto3" json:"time,omitempty"`
	Pos                  []float32 `protobuf:"fixed32,6,rep,packed,name=pos" json:"pos,omitempty"`
	Type                 int32     `protobuf:"varint,7,opt,name=type,proto3" json:"type,omitempty"`
	Raw                  uint64    `protobuf:"varint,8,opt,name=raw,proto3" json:"raw,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CalorimeterHit) Reset()         { *m = CalorimeterHit{} }
func (m *CalorimeterHit) String() string { return proto.CompactTextString(m) }
func (*CalorimeterHit) ProtoMessage()    {}
func (*CalorimeterHit) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{16}
}
func (m *CalorimeterHit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CalorimeterHit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalorimeterHit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CalorimeterHit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalorimeterHit.Merge(dst, src)
}
func (m *CalorimeterHit) XXX_Size() int {
	return m.Size()
}
func (m *CalorimeterHit) XXX_DiscardUnknown() {
	xxx_messageInfo_CalorimeterHit.DiscardUnknown(m)
}

var xxx_messageInfo_CalorimeterHit proto.InternalMessageInfo

func (m *CalorimeterHit) GetCellID0() int32 {
	if m != nil {
		return m.CellID0
	}
	return 0
}

func (m *CalorimeterHit) GetCellID1() int32 {
	if m != nil {
		return m.CellID1
	}
	return 0
}

func (m *CalorimeterHit) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *CalorimeterHit) GetEnergyErr() float32 {
	if m != nil {
		return m.EnergyErr
	}
	return 0
}

func (m *CalorimeterHit) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *CalorimeterHit) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *CalorimeterHit) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CalorimeterHit) GetRaw() uint64 {
	if m != nil {
		return m.Raw
	}
	return 0
}

type Cluster struct {
	Type                 int32         `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Energy               float32       `protobuf:"fixed32,2,opt,name=energy,proto3" json:"energy,omitempty"`
	EnergyErr            float32       `protobuf:"fixed32,3,opt,name=energyErr,proto3" json:"energyErr,omitempty"`
	Pos                  []float32     `protobuf:"fixed32,4,rep,packed,name=pos" json:"pos,omitempty"`
	PosErr               []float32     `protobuf:"fixed32,5,rep,packed,name=posErr" json:"posErr,omitempty"`
	Theta                float32       `protobuf:"fixed32,6,opt,name=theta,proto3" json:"theta,omitempty"`
	Phi                  float32       `protobuf:"fixed32,7,opt,name=phi,proto3" json:"phi,omitempty"`
	DirErr               []float32     `protobuf:"fixed32,8,rep,packed,name=dirErr" json:"dirErr,omitempty"`
	Shape                []float32     `protobuf:"fixed32,9,rep,packed,name=shape" json:"shape,omitempty"`
	PIDs                 []*ParticleID `protobuf:"bytes,10,rep,name=PIDs" json:"PIDs,omitempty"`
	Clusters             []uint64      `protobuf:"varint,11,rep,packed,name=clusters" json:"clusters,omitempty"`
	Hits                 []uint64      `protobuf:"varint,12,rep,packed,name=hits" json:"hits,omitempty"`
	Weights              []float32     `protobuf:"fixed32,13,rep,packed,name=weights" json:"weights,omitempty"`
	SubDetEnes           []float32     `protobuf:"fixed32,14,rep,packed,name=subDetEnes" json:"subDetEnes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{17}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(dst, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Cluster) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *Cluster) GetEnergyErr() float32 {
	if m != nil {
		return m.EnergyErr
	}
	return 0
}

func (m *Cluster) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Cluster) GetPosErr() []float32 {
	if m != nil {
		return m.PosErr
	}
	return nil
}

func (m *Cluster) GetTheta() float32 {
	if m != nil {
		return m.Theta
	}
	return 0
}

func (m *Cluster) GetPhi() float32 {
	if m != nil {
		return m.Phi
	}
	return 0
}

func (m *Cluster) GetDirErr() []float32 {
	if m != nil {
		return m.DirErr
	}
	return nil
}

func (m *Cluster) GetShape() []float32 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *Cluster) GetPIDs() []*ParticleID {
	if m != nil {
		return m.PIDs
	}
	return nil
}

func (m *Cluster) GetClusters() []uint64 {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *Cluster) GetHits() []uint64 {
	if m != nil {
		return m.Hits
	}
	return nil
}

func (m *Cluster) GetWeights() []float32 {
	if m != nil {
		return m.Weights
	}
	return nil
}

func (m *Cluster) GetSubDetEnes() []float32 {
	if m != nil {
		return m.SubDetEnes
	}
	return nil
}

type RecParticle struct {
	Type                 int32         `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	P                    []float32     `protobuf:"fixed32,2,rep,packed,name=p" json:"p,omitempty"`
	Energy               float32       `protobuf:"fixed32,3,opt,name=energy,proto3" json:"energy,omitempty"`
	Cov                  []float32     `protobuf:"fixed32,4,rep,packed,name=cov" json:"cov,omitempty"`
	Mass                 float32       `protobuf:"fixed32,5,opt,name=mass,proto3" json:"mass,omitempty"`
	Charge               float32       `protobuf:"fixed32,6,opt,name=charge,proto3" json:"charge,omitempty"`
	Ref                  []float32     `protobuf:"fixed32,7,rep,packed,name=ref" json:"ref,omitempty"`
	PIDs                 []*ParticleID `protobuf:"bytes,8,rep,name=PIDs" json:"PIDs,omitempty"`
	PIDUsed              int32         `protobuf:"varint,9,opt,name=PIDUsed,proto3" json:"PIDUsed,omitempty"`
	GoodnessOfPID        float32       `protobuf:"fixed32,10,opt,name=goodnessOfPID,proto3" json:"goodnessOfPID,omitempty"`
	Recs                 []uint64      `protobuf:"varint,11,rep,packed,name=recs" json:"recs,omitempty"`
	Tracks               []uint64      `protobuf:"varint,12,rep,packed,name=tracks" json:"tracks,omitempty"`
	Clusters             []uint64      `protobuf:"varint,13,rep,packed,name=clusters" json:"clusters,omitempty"`
	StartVtx             uint64        `protobuf:"varint,14,opt,name=startVtx,proto3" json:"startVtx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RecParticle) Reset()         { *m = RecParticle{} }
func (m *RecParticle) String() string { return proto.CompactTextString(m) }
func (*RecParticle) ProtoMessage()    {}
func (*RecParticle) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{18}
}
func (m *RecParticle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecParticle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecParticle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RecParticle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecParticle.Merge(dst, src)
}
func (m *RecParticle) XXX_Size() int {
	return m.Size()
}
func (m *RecParticle) XXX_DiscardUnknown() {
	xxx_messageInfo_RecParticle.DiscardUnknown(m)
}

var xxx_messageInfo_RecParticle proto.InternalMessageInfo

func (m *RecParticle) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RecParticle) GetP() []float32 {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *RecParticle) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *RecParticle) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *RecParticle) GetMass() float32 {
	if m != nil {
		return m.Mass
	}
	return 0
}

func (m *RecParticle) GetCharge() float32 {
	if m != nil {
		return m.Charge
	}
	return 0
}

func (m *RecParticle) GetRef() []float32 {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *RecParticle) GetPIDs() []*ParticleID {
	if m != nil {
		return m.PIDs
	}
	return nil
}

func (m *RecParticle) GetPIDUsed() int32 {
	if m != nil {
		return m.PIDUsed
	}
	return 0
}

func (m *RecParticle) GetGoodnessOfPID() float32 {
	if m != nil {
		return m.GoodnessOfPID
	}
	return 0
}

func (m *RecParticle) GetRecs() []uint64 {
	if m != nil {
		return m.Recs
	}
	return nil
}

func (m *RecParticle) GetTracks() []uint64 {
	if m != nil {
		return m.Tracks
	}
	return nil
}

func (m *RecParticle) GetClusters() []uint64 {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *RecParticle) GetStartVtx() uint64 {
	if m != nil {
		return m.StartVtx
	}
	return 0
}

type Vertex struct {
	Primary              int32     `protobuf:"varint,1,opt,name=primary,proto3" json:"primary,omitempty"`
	AlgType              int32     `protobuf:"varint,2,opt,name=algType,proto3" json:"algType,omitempty"`
	Chi2                 float32   `protobuf:"fixed32,3,opt,name=chi2,proto3" json:"chi2,omitempty"`
	Prob                 float32   `protobuf:"fixed32,4,opt,name=prob,proto3" json:"prob,omitempty"`
	Pos                  []float32 `protobuf:"fixed32,5,rep,packed,name=pos" json:"pos,omitempty"`
	Cov                  []float32 `protobuf:"fixed32,6,rep,packed,name=cov" json:"cov,omitempty"`
	Params               []float32 `protobuf:"fixed32,7,rep,packed,name=params" json:"params,omitempty"`
	RecPart              uint64    `protobuf:"varint,8,opt,name=recPart,proto3" json:"recPart,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Vertex) Reset()         { *m = Vertex{} }
func (m *Vertex) String() string { return proto.CompactTextString(m) }
func (*Vertex) ProtoMessage()    {}
func (*Vertex) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{19}
}
func (m *Vertex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vertex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vertex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Vertex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vertex.Merge(dst, src)
}
func (m *Vertex) XXX_Size() int {
	return m.Size()
}
func (m *Vertex) XXX_DiscardUnknown() {
	xxx_messageInfo_Vertex.DiscardUnknown(m)
}

var xxx_messageInfo_Vertex proto.InternalMessageInfo

func (m *Vertex) GetPrimary() int32 {
	if m != nil {
		return m.Primary
	}
	return 0
}

func (m *Vertex) GetAlgType() int32 {
	if m != nil {
		return m.AlgType
	}
	return 0
}

func (m *Vertex) GetChi2() float32 {
	if m != nil {
		return m.Chi2
	}
	return 0
}

func (m *Vertex) GetProb() float32 {
	if m != nil {
		return m.Prob
	}
	return 0
}

func (m *Vertex) GetPos() []float32 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *Vertex) GetCov() []float32 {
	if m != nil {
		return m.Cov
	}
	return nil
}

func (m *Vertex) GetParams() []float32 {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Vertex) GetRecPart() uint64 {
	if m != nil {
		return m.RecPart
	}
	return 0
}

type Relation struct {
	From                 uint64   `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"`
	To                   uint64   `protobuf:"varint,2,opt,name=to,proto3" json:"to,omitempty"`
	Weight               float32  `protobuf:"fixed32,3,opt,name=weight,proto3" json:"weight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Relation) Reset()         { *m = Relation{} }
func (m *Relation) String() string { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()    {}
func (*Relation) Descriptor() ([]byte, []int) {
	return fileDescriptor_lcio_65cad8ea5678ebd9, []int{20}
}
func (m *Relation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Relation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Relation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Relation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Relation.Merge(dst, src)
}
func (m *Relation) XXX_Size() int {
	return m.Size()
}
func (m *Relation) XXX_DiscardUnknown() {
	xxx_messageInfo_Relation.DiscardUnknown(m)
}

var xxx_messageInfo_Relation proto.InternalMessageInfo

func (m *Relation) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Relation) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *Relation) GetWeight() float32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func init() {
	proto.RegisterType((*IntParams)(nil), "proio.model.lcio.IntParams")
	proto.RegisterType((*FloatParams)(nil), "proio.model.lcio.FloatParams")
	proto.RegisterType((*StringParams)(nil), "proio.model.lcio.StringParams")
	proto.RegisterType((*Params)(nil), "proio.model.lcio.Params")
	proto.RegisterMapType((map[string]*FloatParams)(nil), "proio.model.lcio.Params.FloatsEntry")
	proto.RegisterMapType((map[string]*IntParams)(nil), "proio.model.lcio.Params.IntsEntry")
	proto.RegisterMapType((map[string]*StringParams)(nil), "proio.model.lcio.Params.StringsEntry")
	proto.RegisterType((*ParticleID)(nil), "proio.model.lcio.ParticleID")
	proto.RegisterType((*MCParticle)(nil), "proio.model.lcio.MCParticle")
	proto.RegisterType((*SimTrackerHit)(nil), "proio.model.lcio.SimTrackerHit")
	proto.RegisterType((*TrackerRawData)(nil), "proio.model.lcio.TrackerRawData")
	proto.RegisterType((*TrackerData)(nil), "proio.model.lcio.TrackerData")
	proto.RegisterType((*TrackerHit)(nil), "proio.model.lcio.TrackerHit")
	proto.RegisterType((*TrackerPulse)(nil), "proio.model.lcio.TrackerPulse")
	proto.RegisterType((*TrackerHitPlane)(nil), "proio.model.lcio.TrackerHitPlane")
	proto.RegisterType((*TrackerHitZCylinder)(nil), "proio.model.lcio.TrackerHitZCylinder")
	proto.RegisterType((*Track)(nil), "proio.model.lcio.Track")
	proto.RegisterType((*Track_TrackState)(nil), "proio.model.lcio.Track.TrackState")
	proto.RegisterType((*SimCalorimeterHit)(nil), "proio.model.lcio.SimCalorimeterHit")
	proto.RegisterType((*SimCalorimeterHit_Contrib)(nil), "proio.model.lcio.SimCalorimeterHit.Contrib")
	proto.RegisterType((*RawCalorimeterHit)(nil), "proio.model.lcio.RawCalorimeterHit")
	proto.RegisterType((*CalorimeterHit)(nil), "proio.model.lcio.CalorimeterHit")
	proto.RegisterType((*Cluster)(nil), "proio.model.lcio.Cluster")
	proto.RegisterType((*RecParticle)(nil), "proio.model.lcio.RecParticle")
	proto.RegisterType((*Vertex)(nil), "proio.model.lcio.Vertex")
	proto.RegisterType((*Relation)(nil), "proio.model.lcio.Relation")
}
func (m *IntParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Array) > 0 {
		dAtA2 := make([]byte, len(m.Array)*10)
		var j1 int
		for _, num1 := range m.Array {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FloatParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Array) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Array)*4))
		for _, num := range m.Array {
			f3 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f3))
			i += 4
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StringParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Array) > 0 {
		for _, s := range m.Array {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ints) > 0 {
		for k, _ := range m.Ints {
			dAtA[i] = 0xa
			i++
			v := m.Ints[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovLcio(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovLcio(uint64(len(k))) + msgSize
			i = encodeVarintLcio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintLcio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintLcio(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	if len(m.Floats) > 0 {
		for k, _ := range m.Floats {
			dAtA[i] = 0x12
			i++
			v := m.Floats[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovLcio(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovLcio(uint64(len(k))) + msgSize
			i = encodeVarintLcio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintLcio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintLcio(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if len(m.Strings) > 0 {
		for k, _ := range m.Strings {
			dAtA[i] = 0x1a
			i++
			v := m.Strings[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovLcio(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovLcio(uint64(len(k))) + msgSize
			i = encodeVarintLcio(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintLcio(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintLcio(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ParticleID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParticleID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Likelihood != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Likelihood))))
		i += 4
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.PDG != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PDG))
	}
	if m.AlgType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.AlgType))
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Params)*4))
		for _, num := range m.Params {
			f7 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f7))
			i += 4
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MCParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MCParticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Parents) > 0 {
		dAtA9 := make([]byte, len(m.Parents)*10)
		var j8 int
		for _, num := range m.Parents {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if len(m.Children) > 0 {
		dAtA11 := make([]byte, len(m.Children)*10)
		var j10 int
		for _, num := range m.Children {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.PDG != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PDG))
	}
	if len(m.Vertex) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Vertex)*8))
		for _, num := range m.Vertex {
			f12 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f12))
			i += 8
		}
	}
	if m.Time != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.P)*8))
		for _, num := range m.P {
			f13 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f13))
			i += 8
		}
	}
	if m.Mass != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mass))))
		i += 8
	}
	if m.Charge != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Charge))))
		i += 4
	}
	if len(m.PEndPoint) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.PEndPoint)*8))
		for _, num := range m.PEndPoint {
			f14 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f14))
			i += 8
		}
	}
	if len(m.Spin) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Spin)*4))
		for _, num := range m.Spin {
			f15 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f15))
			i += 4
		}
	}
	if len(m.ColorFlow) > 0 {
		dAtA17 := make([]byte, len(m.ColorFlow)*10)
		var j16 int
		for _, num1 := range m.ColorFlow {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if m.GenStatus != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.GenStatus))
	}
	if m.SimStatus != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.SimStatus))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SimTrackerHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimTrackerHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f18 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f18))
			i += 8
		}
	}
	if m.EDep != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Mc != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Mc))
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.P)*4))
		for _, num := range m.P {
			f19 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f19))
			i += 4
		}
	}
	if m.PathLength != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PathLength))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrackerRawData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerRawData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Time))
	}
	if len(m.ADCs) > 0 {
		dAtA21 := make([]byte, len(m.ADCs)*10)
		var j20 int
		for _, num := range m.ADCs {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrackerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if len(m.Charges) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Charges)*4))
		for _, num := range m.Charges {
			f22 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f22))
			i += 4
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrackerHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f23 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f23))
			i += 8
		}
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*8))
		for _, num := range m.Cov {
			f24 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f24))
			i += 8
		}
	}
	if m.EDep != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDepErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		dAtA26 := make([]byte, len(m.RawHits)*10)
		var j25 int
		for _, num := range m.RawHits {
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA26[:j25])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrackerPulse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerPulse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Time != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Charge != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Charge))))
		i += 4
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f27 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f27))
			i += 4
		}
	}
	if m.Quality != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if m.TPC != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.TPC))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrackerHitPlane) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitPlane) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f28 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f28))
			i += 8
		}
	}
	if len(m.U) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.U)*4))
		for _, num := range m.U {
			f29 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f29))
			i += 4
		}
	}
	if len(m.V) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.V)*4))
		for _, num := range m.V {
			f30 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f30))
			i += 4
		}
	}
	if m.DU != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DU))))
		i += 4
	}
	if m.DV != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DV))))
		i += 4
	}
	if m.EDep != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x55
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDepErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x5d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		dAtA32 := make([]byte, len(m.RawHits)*10)
		var j31 int
		for _, num := range m.RawHits {
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		dAtA[i] = 0x6a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j31))
		i += copy(dAtA[i:], dAtA32[:j31])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TrackerHitZCylinder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrackerHitZCylinder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*8))
		for _, num := range m.Pos {
			f33 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f33))
			i += 8
		}
	}
	if len(m.Center) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Center)*4))
		for _, num := range m.Center {
			f34 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f34))
			i += 4
		}
	}
	if m.DRPhi != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DRPhi))))
		i += 4
	}
	if m.DZ != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DZ))))
		i += 4
	}
	if m.EDep != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDep))))
		i += 4
	}
	if m.EDepErr != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EDepErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x55
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.Quality != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		dAtA36 := make([]byte, len(m.RawHits)*10)
		var j35 int
		for _, num := range m.RawHits {
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j35))
		i += copy(dAtA[i:], dAtA36[:j35])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Track) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Track) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.Chi2 != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Chi2))))
		i += 4
	}
	if m.NDF != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.NDF))
	}
	if m.DEdx != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DEdx))))
		i += 4
	}
	if m.DEdxErr != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DEdxErr))))
		i += 4
	}
	if m.Radius != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i += 4
	}
	if len(m.SubDetHits) > 0 {
		dAtA38 := make([]byte, len(m.SubDetHits)*10)
		var j37 int
		for _, num1 := range m.SubDetHits {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j37))
		i += copy(dAtA[i:], dAtA38[:j37])
	}
	if len(m.States) > 0 {
		for _, msg := range m.States {
			dAtA[i] = 0x42
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Hits) > 0 {
		dAtA40 := make([]byte, len(m.Hits)*10)
		var j39 int
		for _, num := range m.Hits {
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j39))
		i += copy(dAtA[i:], dAtA40[:j39])
	}
	if len(m.Tracks) > 0 {
		dAtA42 := make([]byte, len(m.Tracks)*10)
		var j41 int
		for _, num := range m.Tracks {
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j41))
		i += copy(dAtA[i:], dAtA42[:j41])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Track_TrackState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Track_TrackState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Loc != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Loc))
	}
	if m.D0 != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.D0))))
		i += 4
	}
	if m.Phi != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Phi))))
		i += 4
	}
	if m.Omega != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Omega))))
		i += 4
	}
	if m.Z0 != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z0))))
		i += 4
	}
	if m.TanL != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TanL))))
		i += 4
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f43 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f43))
			i += 4
		}
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Ref)*4))
		for _, num := range m.Ref {
			f44 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f44))
			i += 4
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SimCalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f45 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f45))
			i += 4
		}
	}
	if len(m.Contributions) > 0 {
		for _, msg := range m.Contributions {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SimCalorimeterHit_Contrib) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimCalorimeterHit_Contrib) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MCParticle != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.MCParticle))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if m.PDG != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PDG))
	}
	if len(m.StepPos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.StepPos)*4))
		for _, num := range m.StepPos {
			f46 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f46))
			i += 4
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RawCalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Amplitude != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Amplitude))
	}
	if m.TimeStamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.TimeStamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CalorimeterHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalorimeterHit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellID0 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.CellID1))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if m.EnergyErr != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EnergyErr))))
		i += 4
	}
	if m.Time != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f47 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f47))
			i += 4
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.Raw != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Raw))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if m.EnergyErr != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EnergyErr))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f48 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f48))
			i += 4
		}
	}
	if len(m.PosErr) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.PosErr)*4))
		for _, num := range m.PosErr {
			f49 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f49))
			i += 4
		}
	}
	if m.Theta != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Theta))))
		i += 4
	}
	if m.Phi != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Phi))))
		i += 4
	}
	if len(m.DirErr) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.DirErr)*4))
		for _, num := range m.DirErr {
			f50 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f50))
			i += 4
		}
	}
	if len(m.Shape) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Shape)*4))
		for _, num := range m.Shape {
			f51 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f51))
			i += 4
		}
	}
	if len(m.PIDs) > 0 {
		for _, msg := range m.PIDs {
			dAtA[i] = 0x52
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Clusters) > 0 {
		dAtA53 := make([]byte, len(m.Clusters)*10)
		var j52 int
		for _, num := range m.Clusters {
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j52))
		i += copy(dAtA[i:], dAtA53[:j52])
	}
	if len(m.Hits) > 0 {
		dAtA55 := make([]byte, len(m.Hits)*10)
		var j54 int
		for _, num := range m.Hits {
			for num >= 1<<7 {
				dAtA55[j54] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j54++
			}
			dAtA55[j54] = uint8(num)
			j54++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j54))
		i += copy(dAtA[i:], dAtA55[:j54])
	}
	if len(m.Weights) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Weights)*4))
		for _, num := range m.Weights {
			f56 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f56))
			i += 4
		}
	}
	if len(m.SubDetEnes) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.SubDetEnes)*4))
		for _, num := range m.SubDetEnes {
			f57 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f57))
			i += 4
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RecParticle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecParticle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Type))
	}
	if len(m.P) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.P)*4))
		for _, num := range m.P {
			f58 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f58))
			i += 4
		}
	}
	if m.Energy != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f59 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f59))
			i += 4
		}
	}
	if m.Mass != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Mass))))
		i += 4
	}
	if m.Charge != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Charge))))
		i += 4
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Ref)*4))
		for _, num := range m.Ref {
			f60 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f60))
			i += 4
		}
	}
	if len(m.PIDs) > 0 {
		for _, msg := range m.PIDs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintLcio(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PIDUsed != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.PIDUsed))
	}
	if m.GoodnessOfPID != 0 {
		dAtA[i] = 0x55
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GoodnessOfPID))))
		i += 4
	}
	if len(m.Recs) > 0 {
		dAtA62 := make([]byte, len(m.Recs)*10)
		var j61 int
		for _, num := range m.Recs {
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j61))
		i += copy(dAtA[i:], dAtA62[:j61])
	}
	if len(m.Tracks) > 0 {
		dAtA64 := make([]byte, len(m.Tracks)*10)
		var j63 int
		for _, num := range m.Tracks {
			for num >= 1<<7 {
				dAtA64[j63] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j63++
			}
			dAtA64[j63] = uint8(num)
			j63++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j63))
		i += copy(dAtA[i:], dAtA64[:j63])
	}
	if len(m.Clusters) > 0 {
		dAtA66 := make([]byte, len(m.Clusters)*10)
		var j65 int
		for _, num := range m.Clusters {
			for num >= 1<<7 {
				dAtA66[j65] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j65++
			}
			dAtA66[j65] = uint8(num)
			j65++
		}
		dAtA[i] = 0x6a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(j65))
		i += copy(dAtA[i:], dAtA66[:j65])
	}
	if m.StartVtx != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.StartVtx))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Vertex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vertex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Primary != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.Primary))
	}
	if m.AlgType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.AlgType))
	}
	if m.Chi2 != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Chi2))))
		i += 4
	}
	if m.Prob != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Prob))))
		i += 4
	}
	if len(m.Pos) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Pos)*4))
		for _, num := range m.Pos {
			f67 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f67))
			i += 4
		}
	}
	if len(m.Cov) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Cov)*4))
		for _, num := range m.Cov {
			f68 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f68))
			i += 4
		}
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLcio(dAtA, i, uint64(len(m.Params)*4))
		for _, num := range m.Params {
			f69 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f69))
			i += 4
		}
	}
	if m.RecPart != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.RecPart))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Relation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.From))
	}
	if m.To != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLcio(dAtA, i, uint64(m.To))
	}
	if m.Weight != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Weight))))
		i += 4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintLcio(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *IntParams) Size() (n int) {
	var l int
	_ = l
	if len(m.Array) > 0 {
		l = 0
		for _, e := range m.Array {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FloatParams) Size() (n int) {
	var l int
	_ = l
	if len(m.Array) > 0 {
		n += 1 + sovLcio(uint64(len(m.Array)*4)) + len(m.Array)*4
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringParams) Size() (n int) {
	var l int
	_ = l
	if len(m.Array) > 0 {
		for _, s := range m.Array {
			l = len(s)
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Params) Size() (n int) {
	var l int
	_ = l
	if len(m.Ints) > 0 {
		for k, v := range m.Ints {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovLcio(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovLcio(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovLcio(uint64(mapEntrySize))
		}
	}
	if len(m.Floats) > 0 {
		for k, v := range m.Floats {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovLcio(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovLcio(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovLcio(uint64(mapEntrySize))
		}
	}
	if len(m.Strings) > 0 {
		for k, v := range m.Strings {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovLcio(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovLcio(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovLcio(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ParticleID) Size() (n int) {
	var l int
	_ = l
	if m.Likelihood != 0 {
		n += 5
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.PDG != 0 {
		n += 1 + sovLcio(uint64(m.PDG))
	}
	if m.AlgType != 0 {
		n += 1 + sovLcio(uint64(m.AlgType))
	}
	if len(m.Params) > 0 {
		n += 1 + sovLcio(uint64(len(m.Params)*4)) + len(m.Params)*4
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MCParticle) Size() (n int) {
	var l int
	_ = l
	if len(m.Parents) > 0 {
		l = 0
		for _, e := range m.Parents {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Children) > 0 {
		l = 0
		for _, e := range m.Children {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.PDG != 0 {
		n += 1 + sovLcio(uint64(m.PDG))
	}
	if len(m.Vertex) > 0 {
		n += 1 + sovLcio(uint64(len(m.Vertex)*8)) + len(m.Vertex)*8
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.P) > 0 {
		n += 1 + sovLcio(uint64(len(m.P)*8)) + len(m.P)*8
	}
	if m.Mass != 0 {
		n += 9
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.PEndPoint) > 0 {
		n += 1 + sovLcio(uint64(len(m.PEndPoint)*8)) + len(m.PEndPoint)*8
	}
	if len(m.Spin) > 0 {
		n += 1 + sovLcio(uint64(len(m.Spin)*4)) + len(m.Spin)*4
	}
	if len(m.ColorFlow) > 0 {
		l = 0
		for _, e := range m.ColorFlow {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.GenStatus != 0 {
		n += 1 + sovLcio(uint64(m.GenStatus))
	}
	if m.SimStatus != 0 {
		n += 1 + sovLcio(uint64(m.SimStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimTrackerHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Mc != 0 {
		n += 1 + sovLcio(uint64(m.Mc))
	}
	if len(m.P) > 0 {
		n += 1 + sovLcio(uint64(len(m.P)*4)) + len(m.P)*4
	}
	if m.PathLength != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrackerRawData) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 1 + sovLcio(uint64(m.Time))
	}
	if len(m.ADCs) > 0 {
		l = 0
		for _, e := range m.ADCs {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrackerData) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.Charges) > 0 {
		n += 1 + sovLcio(uint64(len(m.Charges)*4)) + len(m.Charges)*4
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrackerHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*8)) + len(m.Cov)*8
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		l = 0
		for _, e := range m.RawHits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrackerPulse) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if m.TPC != 0 {
		n += 1 + sovLcio(uint64(m.TPC))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrackerHitPlane) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.U) > 0 {
		n += 1 + sovLcio(uint64(len(m.U)*4)) + len(m.U)*4
	}
	if len(m.V) > 0 {
		n += 1 + sovLcio(uint64(len(m.V)*4)) + len(m.V)*4
	}
	if m.DU != 0 {
		n += 5
	}
	if m.DV != 0 {
		n += 5
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		l = 0
		for _, e := range m.RawHits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrackerHitZCylinder) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*8)) + len(m.Pos)*8
	}
	if len(m.Center) > 0 {
		n += 1 + sovLcio(uint64(len(m.Center)*4)) + len(m.Center)*4
	}
	if m.DRPhi != 0 {
		n += 5
	}
	if m.DZ != 0 {
		n += 5
	}
	if m.EDep != 0 {
		n += 5
	}
	if m.EDepErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.Quality != 0 {
		n += 1 + sovLcio(uint64(m.Quality))
	}
	if len(m.RawHits) > 0 {
		l = 0
		for _, e := range m.RawHits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Track) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.Chi2 != 0 {
		n += 5
	}
	if m.NDF != 0 {
		n += 1 + sovLcio(uint64(m.NDF))
	}
	if m.DEdx != 0 {
		n += 5
	}
	if m.DEdxErr != 0 {
		n += 5
	}
	if m.Radius != 0 {
		n += 5
	}
	if len(m.SubDetHits) > 0 {
		l = 0
		for _, e := range m.SubDetHits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.States) > 0 {
		for _, e := range m.States {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Hits) > 0 {
		l = 0
		for _, e := range m.Hits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Tracks) > 0 {
		l = 0
		for _, e := range m.Tracks {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Track_TrackState) Size() (n int) {
	var l int
	_ = l
	if m.Loc != 0 {
		n += 1 + sovLcio(uint64(m.Loc))
	}
	if m.D0 != 0 {
		n += 5
	}
	if m.Phi != 0 {
		n += 5
	}
	if m.Omega != 0 {
		n += 5
	}
	if m.Z0 != 0 {
		n += 5
	}
	if m.TanL != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if len(m.Ref) > 0 {
		n += 1 + sovLcio(uint64(len(m.Ref)*4)) + len(m.Ref)*4
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimCalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Energy != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.Contributions) > 0 {
		for _, e := range m.Contributions {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimCalorimeterHit_Contrib) Size() (n int) {
	var l int
	_ = l
	if m.MCParticle != 0 {
		n += 1 + sovLcio(uint64(m.MCParticle))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.PDG != 0 {
		n += 1 + sovLcio(uint64(m.PDG))
	}
	if len(m.StepPos) > 0 {
		n += 1 + sovLcio(uint64(len(m.StepPos)*4)) + len(m.StepPos)*4
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawCalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Amplitude != 0 {
		n += 1 + sovLcio(uint64(m.Amplitude))
	}
	if m.TimeStamp != 0 {
		n += 1 + sovLcio(uint64(m.TimeStamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CalorimeterHit) Size() (n int) {
	var l int
	_ = l
	if m.CellID0 != 0 {
		n += 1 + sovLcio(uint64(m.CellID0))
	}
	if m.CellID1 != 0 {
		n += 1 + sovLcio(uint64(m.CellID1))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.EnergyErr != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.Raw != 0 {
		n += 1 + sovLcio(uint64(m.Raw))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if m.Energy != 0 {
		n += 5
	}
	if m.EnergyErr != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.PosErr) > 0 {
		n += 1 + sovLcio(uint64(len(m.PosErr)*4)) + len(m.PosErr)*4
	}
	if m.Theta != 0 {
		n += 5
	}
	if m.Phi != 0 {
		n += 5
	}
	if len(m.DirErr) > 0 {
		n += 1 + sovLcio(uint64(len(m.DirErr)*4)) + len(m.DirErr)*4
	}
	if len(m.Shape) > 0 {
		n += 1 + sovLcio(uint64(len(m.Shape)*4)) + len(m.Shape)*4
	}
	if len(m.PIDs) > 0 {
		for _, e := range m.PIDs {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if len(m.Clusters) > 0 {
		l = 0
		for _, e := range m.Clusters {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Hits) > 0 {
		l = 0
		for _, e := range m.Hits {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Weights) > 0 {
		n += 1 + sovLcio(uint64(len(m.Weights)*4)) + len(m.Weights)*4
	}
	if len(m.SubDetEnes) > 0 {
		n += 1 + sovLcio(uint64(len(m.SubDetEnes)*4)) + len(m.SubDetEnes)*4
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecParticle) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovLcio(uint64(m.Type))
	}
	if len(m.P) > 0 {
		n += 1 + sovLcio(uint64(len(m.P)*4)) + len(m.P)*4
	}
	if m.Energy != 0 {
		n += 5
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if m.Mass != 0 {
		n += 5
	}
	if m.Charge != 0 {
		n += 5
	}
	if len(m.Ref) > 0 {
		n += 1 + sovLcio(uint64(len(m.Ref)*4)) + len(m.Ref)*4
	}
	if len(m.PIDs) > 0 {
		for _, e := range m.PIDs {
			l = e.Size()
			n += 1 + l + sovLcio(uint64(l))
		}
	}
	if m.PIDUsed != 0 {
		n += 1 + sovLcio(uint64(m.PIDUsed))
	}
	if m.GoodnessOfPID != 0 {
		n += 5
	}
	if len(m.Recs) > 0 {
		l = 0
		for _, e := range m.Recs {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Tracks) > 0 {
		l = 0
		for _, e := range m.Tracks {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if len(m.Clusters) > 0 {
		l = 0
		for _, e := range m.Clusters {
			l += sovLcio(uint64(e))
		}
		n += 1 + sovLcio(uint64(l)) + l
	}
	if m.StartVtx != 0 {
		n += 1 + sovLcio(uint64(m.StartVtx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vertex) Size() (n int) {
	var l int
	_ = l
	if m.Primary != 0 {
		n += 1 + sovLcio(uint64(m.Primary))
	}
	if m.AlgType != 0 {
		n += 1 + sovLcio(uint64(m.AlgType))
	}
	if m.Chi2 != 0 {
		n += 5
	}
	if m.Prob != 0 {
		n += 5
	}
	if len(m.Pos) > 0 {
		n += 1 + sovLcio(uint64(len(m.Pos)*4)) + len(m.Pos)*4
	}
	if len(m.Cov) > 0 {
		n += 1 + sovLcio(uint64(len(m.Cov)*4)) + len(m.Cov)*4
	}
	if len(m.Params) > 0 {
		n += 1 + sovLcio(uint64(len(m.Params)*4)) + len(m.Params)*4
	}
	if m.RecPart != 0 {
		n += 1 + sovLcio(uint64(m.RecPart))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Relation) Size() (n int) {
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovLcio(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovLcio(uint64(m.To))
	}
	if m.Weight != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLcio(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLcio(x uint64) (n int) {
	return sovLcio(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IntParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Array = append(m.Array, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Array = append(m.Array, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Array = append(m.Array, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Array = append(m.Array, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Array = append(m.Array, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ints == nil {
				m.Ints = make(map[string]*IntParams)
			}
			var mapkey string
			var mapvalue *IntParams
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLcio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &IntParams{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLcio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLcio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ints[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Floats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Floats == nil {
				m.Floats = make(map[string]*FloatParams)
			}
			var mapkey string
			var mapvalue *FloatParams
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLcio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FloatParams{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLcio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLcio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Floats[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strings == nil {
				m.Strings = make(map[string]*StringParams)
			}
			var mapkey string
			var mapvalue *StringParams
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLcio
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthLcio
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StringParams{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLcio(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLcio
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Strings[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParticleID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParticleID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParticleID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Likelihood", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Likelihood = float32(math.Float32frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgType", wireType)
			}
			m.AlgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Params = append(m.Params, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Params = append(m.Params, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MCParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MCParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MCParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parents = append(m.Parents, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parents = append(m.Parents, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Children = append(m.Children, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Children = append(m.Children, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Vertex = append(m.Vertex, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Vertex = append(m.Vertex, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vertex", wireType)
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mass = float64(math.Float64frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Charge = float32(math.Float32frombits(v))
		case 9:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.PEndPoint = append(m.PEndPoint, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.PEndPoint = append(m.PEndPoint, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PEndPoint", wireType)
			}
		case 10:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Spin = append(m.Spin, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Spin = append(m.Spin, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Spin", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColorFlow = append(m.ColorFlow, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColorFlow = append(m.ColorFlow, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColorFlow", wireType)
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenStatus", wireType)
			}
			m.GenStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimStatus", wireType)
			}
			m.SimStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SimStatus |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimTrackerHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimTrackerHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimTrackerHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mc", wireType)
			}
			m.Mc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mc |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathLength", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PathLength = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerRawData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerRawData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerRawData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ADCs = append(m.ADCs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ADCs = append(m.ADCs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ADCs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Charges = append(m.Charges, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Charges = append(m.Charges, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Charges", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDepErr = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RawHits = append(m.RawHits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RawHits = append(m.RawHits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerPulse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerPulse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerPulse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Charge = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TPC", wireType)
			}
			m.TPC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TPC |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitPlane) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitPlane: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitPlane: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.U = append(m.U, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.U = append(m.U, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field U", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.V = append(m.V, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.V = append(m.V, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DU = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DV", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DV = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDepErr = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RawHits = append(m.RawHits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RawHits = append(m.RawHits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrackerHitZCylinder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackerHitZCylinder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackerHitZCylinder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Center = append(m.Center, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Center = append(m.Center, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Center", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DRPhi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DRPhi = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DZ = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDep", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDep = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EDepErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EDepErr = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RawHits = append(m.RawHits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RawHits = append(m.RawHits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHits", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Track) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Track: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Track: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chi2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Chi2 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NDF", wireType)
			}
			m.NDF = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NDF |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEdx", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DEdx = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEdxErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DEdxErr = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SubDetHits = append(m.SubDetHits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SubDetHits = append(m.SubDetHits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDetHits", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = append(m.States, &Track_TrackState{})
			if err := m.States[len(m.States)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Hits = append(m.Hits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Hits = append(m.Hits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
		case 10:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tracks = append(m.Tracks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tracks = append(m.Tracks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracks", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Track_TrackState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrackState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrackState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loc", wireType)
			}
			m.Loc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field D0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.D0 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Phi = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Omega", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Omega = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z0", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z0 = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TanL", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TanL = float32(math.Float32frombits(v))
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Ref = append(m.Ref, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Ref = append(m.Ref, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimCalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimCalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contributions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contributions = append(m.Contributions, &SimCalorimeterHit_Contrib{})
			if err := m.Contributions[len(m.Contributions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimCalorimeterHit_Contrib) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contrib: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contrib: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MCParticle", wireType)
			}
			m.MCParticle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MCParticle |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDG", wireType)
			}
			m.PDG = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PDG |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.StepPos = append(m.StepPos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.StepPos = append(m.StepPos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StepPos", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amplitude", wireType)
			}
			m.Amplitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amplitude |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			m.TimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeStamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalorimeterHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalorimeterHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalorimeterHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID0", wireType)
			}
			m.CellID0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID0 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID1", wireType)
			}
			m.CellID1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EnergyErr = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			m.Raw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Raw |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergyErr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EnergyErr = float32(math.Float32frombits(v))
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.PosErr = append(m.PosErr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.PosErr = append(m.PosErr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PosErr", wireType)
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Theta", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Theta = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Phi = float32(math.Float32frombits(v))
		case 8:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.DirErr = append(m.DirErr, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.DirErr = append(m.DirErr, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DirErr", wireType)
			}
		case 9:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Shape = append(m.Shape, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Shape = append(m.Shape, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIDs = append(m.PIDs, &ParticleID{})
			if err := m.PIDs[len(m.PIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Clusters = append(m.Clusters, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Clusters = append(m.Clusters, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Hits = append(m.Hits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Hits = append(m.Hits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
		case 13:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Weights = append(m.Weights, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Weights = append(m.Weights, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Weights", wireType)
			}
		case 14:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.SubDetEnes = append(m.SubDetEnes, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.SubDetEnes = append(m.SubDetEnes, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDetEnes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecParticle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecParticle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecParticle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.P = append(m.P, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.P = append(m.P, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 4:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mass", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Mass = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Charge = float32(math.Float32frombits(v))
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Ref = append(m.Ref, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Ref = append(m.Ref, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcio
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIDs = append(m.PIDs, &ParticleID{})
			if err := m.PIDs[len(m.PIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIDUsed", wireType)
			}
			m.PIDUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PIDUsed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodnessOfPID", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GoodnessOfPID = float32(math.Float32frombits(v))
		case 11:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Recs = append(m.Recs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Recs = append(m.Recs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Recs", wireType)
			}
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tracks = append(m.Tracks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tracks = append(m.Tracks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracks", wireType)
			}
		case 13:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Clusters = append(m.Clusters, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLcio
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Clusters = append(m.Clusters, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVtx", wireType)
			}
			m.StartVtx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVtx |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vertex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vertex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vertex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			m.Primary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Primary |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgType", wireType)
			}
			m.AlgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chi2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Chi2 = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prob", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Prob = float32(math.Float32frombits(v))
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Pos = append(m.Pos, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Pos = append(m.Pos, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Cov = append(m.Cov, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Cov = append(m.Cov, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cov", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Params = append(m.Params, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLcio
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Params = append(m.Params, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecPart", wireType)
			}
			m.RecPart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecPart |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Weight = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipLcio(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLcio
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLcio(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLcio
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLcio
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLcio
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLcio
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLcio(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLcio = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLcio   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proio/model/lcio.proto", fileDescriptor_lcio_65cad8ea5678ebd9) }

var fileDescriptor_lcio_65cad8ea5678ebd9 = []byte{
	// 1664 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4f, 0x6f, 0xe4, 0x48,
	0x15, 0xc7, 0x6e, 0x77, 0x77, 0xfa, 0x75, 0x27, 0x64, 0x0d, 0x8a, 0xac, 0x30, 0x44, 0xc1, 0x0c,
	0x52, 0x24, 0x44, 0x26, 0x9b, 0x45, 0x08, 0xad, 0x90, 0x10, 0x9b, 0x4e, 0xd8, 0x48, 0xc3, 0xd2,
	0x54, 0x26, 0x01, 0xe5, 0x56, 0xb1, 0x6b, 0xba, 0xad, 0x71, 0xbb, 0x4c, 0xb9, 0x7a, 0x32, 0xd9,
	0x1b, 0x82, 0x0f, 0xc1, 0x05, 0x2e, 0x5c, 0x39, 0x70, 0xe6, 0x03, 0xac, 0x56, 0xe2, 0xc2, 0x85,
	0x3b, 0x1a, 0xce, 0xc0, 0x57, 0x40, 0xef, 0x55, 0x55, 0xdb, 0xce, 0x38, 0x08, 0x2d, 0x33, 0x97,
	0xe4, 0xbd, 0x57, 0x7f, 0xfc, 0xde, 0xef, 0xf7, 0xde, 0xab, 0xaa, 0x86, 0x9d, 0x52, 0xc9, 0x4c,
	0x3e, 0x59, 0xca, 0x54, 0xe4, 0x4f, 0xf2, 0x24, 0x93, 0x87, 0xa5, 0x92, 0x5a, 0x86, 0xdb, 0x64,
	0x3f, 0x24, 0xfb, 0x21, 0xda, 0xe3, 0x6f, 0xc0, 0xe8, 0xbc, 0xd0, 0x33, 0xae, 0xf8, 0xb2, 0x0a,
	0xbf, 0x0a, 0x7d, 0xae, 0x14, 0xbf, 0x8b, 0xbc, 0xfd, 0xde, 0x41, 0x9f, 0x19, 0x25, 0xfe, 0x26,
	0x8c, 0xcf, 0x72, 0xc9, 0x3b, 0x27, 0xf9, 0x6e, 0xd2, 0x63, 0x98, 0x5c, 0x68, 0x95, 0x15, 0xf3,
	0xae, 0x59, 0x23, 0x37, 0xeb, 0x2f, 0x3d, 0x18, 0xd8, 0x09, 0xdf, 0x83, 0x20, 0x2b, 0x74, 0x45,
	0xe3, 0xe3, 0xe3, 0xf8, 0xf0, 0xbe, 0x67, 0x87, 0x66, 0xde, 0xe1, 0x79, 0xa1, 0xab, 0xd3, 0x42,
	0xab, 0x3b, 0x46, 0xf3, 0xc3, 0x1f, 0xc0, 0xe0, 0x39, 0x7a, 0x53, 0x45, 0x3e, 0xad, 0x7c, 0xfc,
	0xe0, 0x4a, 0x72, 0xda, 0xae, 0xb5, 0x6b, 0xc2, 0x1f, 0xc2, 0xb0, 0x22, 0x37, 0xab, 0xa8, 0x47,
	0xcb, 0xbf, 0xf5, 0xe0, 0x72, 0x13, 0x8e, 0x5d, 0xef, 0x56, 0xed, 0x3e, 0x23, 0xbc, 0x8c, 0x35,
	0xdc, 0x86, 0xde, 0x0b, 0x81, 0x21, 0x7a, 0x07, 0x23, 0x86, 0x62, 0xf8, 0x3e, 0xf4, 0x5f, 0xf2,
	0x7c, 0x25, 0x22, 0x7f, 0xdf, 0x3b, 0x18, 0x1f, 0x7f, 0xed, 0xcd, 0xdd, 0xd7, 0x68, 0x33, 0x33,
	0xf3, 0x43, 0xff, 0xfb, 0xde, 0xee, 0x2f, 0x2c, 0xc4, 0x0f, 0xee, 0xfb, 0x41, 0x7b, 0xdf, 0xaf,
	0xbf, 0xb9, 0x6f, 0x83, 0xa2, 0xe6, 0xce, 0xd7, 0x8e, 0x97, 0x07, 0xb7, 0xfe, 0x6e, 0x7b, 0xeb,
	0xbd, 0x37, 0xb7, 0x6e, 0x12, 0xdb, 0xd8, 0x3b, 0xfe, 0x8d, 0x07, 0x30, 0xe3, 0x4a, 0x67, 0x49,
	0x2e, 0xce, 0xa7, 0xe1, 0x1e, 0x40, 0x9e, 0xbd, 0x10, 0x79, 0xb6, 0x90, 0x32, 0xa5, 0x2f, 0xf8,
	0xac, 0x61, 0x09, 0x43, 0x08, 0xf4, 0x5d, 0x69, 0xbe, 0xd3, 0x67, 0x24, 0xa3, 0x3b, 0xb3, 0xe9,
	0x8f, 0xa3, 0x1e, 0x99, 0x50, 0x0c, 0x23, 0x18, 0xf2, 0x7c, 0xfe, 0x0c, 0x27, 0x06, 0x64, 0x75,
	0x6a, 0xb8, 0x03, 0x83, 0x92, 0x7c, 0x88, 0xfa, 0x94, 0x79, 0x56, 0x8b, 0x3f, 0xf3, 0x01, 0x7e,
	0x72, 0xe2, 0x1c, 0xc1, 0x0d, 0x4a, 0xae, 0x84, 0xcb, 0xad, 0x80, 0x39, 0x35, 0xdc, 0x85, 0x8d,
	0x64, 0x91, 0xe5, 0xa9, 0x12, 0x05, 0x25, 0x4f, 0xc0, 0xd6, 0x7a, 0x87, 0x23, 0x3b, 0x30, 0x78,
	0x29, 0x94, 0x16, 0xaf, 0xa2, 0x60, 0xbf, 0x77, 0xe0, 0x31, 0xab, 0x51, 0x18, 0xd9, 0x52, 0x44,
	0x7d, 0x0a, 0x90, 0xe4, 0x70, 0x02, 0x5e, 0x19, 0x0d, 0x68, 0x9a, 0x57, 0xe2, 0x8c, 0x25, 0xaf,
	0xaa, 0x68, 0xb8, 0xef, 0x1d, 0x78, 0x8c, 0x64, 0xdc, 0x2d, 0x59, 0x70, 0x35, 0x17, 0xd1, 0x06,
	0xad, 0xb3, 0x5a, 0xf8, 0x08, 0x46, 0xb3, 0xd3, 0x22, 0x9d, 0xc9, 0xac, 0xd0, 0xd1, 0x88, 0x76,
	0xa8, 0x0d, 0xb8, 0x53, 0x55, 0x66, 0x45, 0x04, 0x14, 0x30, 0xc9, 0xb8, 0x22, 0x91, 0xb9, 0x54,
	0x67, 0xb9, 0xbc, 0x8d, 0xc6, 0x54, 0xa8, 0xb5, 0x01, 0x47, 0xe7, 0xa2, 0xb8, 0xd0, 0x5c, 0xaf,
	0xaa, 0x68, 0x42, 0xd1, 0xd4, 0x06, 0x1c, 0xad, 0xb2, 0xa5, 0x1d, 0xdd, 0xdc, 0xf7, 0x0e, 0x36,
	0x59, 0x6d, 0x88, 0xff, 0xe6, 0xc1, 0xe6, 0x45, 0xb6, 0x7c, 0xa6, 0x78, 0xf2, 0x42, 0xa8, 0x8f,
	0x33, 0x8d, 0x58, 0x26, 0x22, 0xcf, 0xcf, 0xa7, 0x47, 0xc4, 0x67, 0x9f, 0x39, 0xb5, 0x1e, 0x79,
	0xdf, 0xf2, 0xe9, 0x54, 0x44, 0xb2, 0x94, 0xa6, 0xbc, 0x3c, 0x86, 0x22, 0x46, 0x71, 0x3a, 0x15,
	0x25, 0xf1, 0xe9, 0x33, 0x92, 0x3b, 0x51, 0xdc, 0x02, 0x7f, 0x99, 0x44, 0x83, 0x7d, 0xef, 0x20,
	0x60, 0xfe, 0x32, 0x31, 0xa8, 0x0e, 0x29, 0x74, 0xaf, 0xc4, 0xf4, 0x2a, 0xb9, 0x5e, 0x3c, 0x15,
	0xc5, 0x5c, 0x2f, 0x2c, 0x8a, 0x0d, 0x0b, 0x7a, 0xf4, 0xcb, 0x15, 0xcf, 0x33, 0x7d, 0x17, 0x8d,
	0x8c, 0x47, 0x56, 0x8d, 0x73, 0xd8, 0xb2, 0x31, 0x31, 0x7e, 0x3b, 0xe5, 0x9a, 0x7f, 0xa1, 0xb8,
	0x9c, 0xc7, 0x3d, 0x9b, 0xbe, 0xe8, 0x71, 0x08, 0xc1, 0x8f, 0xa6, 0x27, 0x15, 0x65, 0xc8, 0x26,
	0x23, 0x39, 0x96, 0x30, 0xb6, 0x5f, 0x7b, 0x2b, 0x9f, 0x72, 0xe0, 0xe0, 0x6c, 0x4a, 0x19, 0xf3,
	0x35, 0x9f, 0x39, 0x35, 0xfe, 0x97, 0x07, 0xf0, 0x7f, 0x72, 0xe6, 0x4a, 0xb3, 0xd7, 0x2e, 0x4d,
	0xe4, 0x31, 0xa8, 0x79, 0xdc, 0x86, 0x5e, 0x22, 0x5f, 0x52, 0xf5, 0x79, 0x0c, 0xc5, 0x35, 0xb3,
	0x83, 0x06, 0xb3, 0x11, 0x0c, 0xf1, 0xff, 0xa9, 0x52, 0x54, 0x00, 0x3e, 0x73, 0xea, 0x3a, 0xac,
	0x8d, 0x76, 0x58, 0xdd, 0xac, 0xe1, 0x88, 0xe2, 0xb7, 0x1f, 0x67, 0xba, 0xa2, 0xf4, 0x0f, 0x98,
	0x53, 0xe3, 0x3f, 0x7a, 0x30, 0xb1, 0x01, 0xcf, 0x56, 0x79, 0x25, 0xde, 0x1a, 0xc6, 0x75, 0x91,
	0x06, 0xad, 0x22, 0x6d, 0x04, 0xee, 0x9b, 0xc0, 0x1b, 0x6e, 0x0f, 0xda, 0x6e, 0x6f, 0x43, 0xef,
	0xd9, 0xec, 0x84, 0x42, 0x0f, 0x18, 0x8a, 0xf1, 0xef, 0x7c, 0xf8, 0x72, 0xcd, 0xcf, 0x2c, 0xe7,
	0x85, 0x78, 0x87, 0x24, 0x4d, 0xc0, 0xbb, 0xb4, 0x9e, 0x7a, 0x97, 0xa8, 0x5d, 0x51, 0x63, 0xf2,
	0x99, 0x77, 0x85, 0x05, 0x96, 0x5e, 0x5a, 0x56, 0xfc, 0xf4, 0x92, 0xf4, 0x2b, 0x4b, 0x87, 0x9f,
	0x5e, 0xad, 0xe9, 0x1c, 0x75, 0xd3, 0x09, 0xdd, 0x74, 0x8e, 0xbb, 0xe9, 0x9c, 0x3c, 0x48, 0xe7,
	0x66, 0x9b, 0xce, 0x3f, 0xf8, 0xf0, 0x95, 0x1a, 0x9f, 0xeb, 0x93, 0xbb, 0x3c, 0x2b, 0x52, 0xa1,
	0xde, 0x21, 0x46, 0xc8, 0xb3, 0x28, 0xb4, 0x50, 0xee, 0x24, 0x31, 0x1a, 0x5e, 0x5a, 0x52, 0x36,
	0x5b, 0x64, 0x36, 0x9f, 0x8d, 0x42, 0x28, 0x5d, 0xaf, 0x51, 0xbb, 0x5e, 0xa3, 0xb4, 0xd1, 0x8d,
	0xd2, 0xa8, 0x1b, 0x25, 0xe8, 0x46, 0x69, 0xfc, 0x20, 0x4a, 0x93, 0x36, 0x4a, 0x7f, 0xea, 0x41,
	0x9f, 0x50, 0x5a, 0xc7, 0xe8, 0x35, 0x62, 0x0c, 0x21, 0x48, 0x16, 0xd9, 0x31, 0xc1, 0xe1, 0x33,
	0x92, 0x31, 0xee, 0x4f, 0xa6, 0x67, 0xee, 0x48, 0xfb, 0x64, 0x7a, 0x86, 0xb3, 0xd2, 0xd3, 0xf4,
	0x95, 0x6b, 0xc4, 0x28, 0xe3, 0x17, 0xf1, 0x3f, 0x7a, 0x6e, 0x7a, 0xb1, 0x53, 0x11, 0x25, 0xc5,
	0xd3, 0x6c, 0x55, 0x59, 0x38, 0xac, 0x86, 0x8d, 0xb8, 0x5a, 0xdd, 0x4c, 0x85, 0x26, 0x37, 0x87,
	0x74, 0x02, 0x35, 0x2c, 0xe1, 0x87, 0x30, 0xa8, 0x34, 0xd7, 0xa2, 0x8a, 0x36, 0x1e, 0xba, 0xdb,
	0x51, 0x20, 0xe6, 0x2f, 0x9e, 0x3d, 0x82, 0xd9, 0x15, 0xe8, 0xe1, 0x02, 0x77, 0x1d, 0x51, 0xf0,
	0x24, 0xa3, 0x1f, 0x1a, 0x67, 0xba, 0x3e, 0x60, 0xb5, 0xdd, 0xdf, 0xbb, 0xbe, 0x47, 0x5b, 0x60,
	0xb8, 0xb9, 0x4c, 0x2c, 0x2a, 0x28, 0x12, 0x71, 0x47, 0x16, 0x12, 0x3f, 0x3d, 0xa2, 0x44, 0x58,
	0x64, 0xb6, 0xe2, 0x51, 0x44, 0xc2, 0xe5, 0x52, 0xcc, 0xb9, 0x45, 0xc4, 0x28, 0xb8, 0xee, 0xd3,
	0x23, 0x8b, 0x86, 0xff, 0xe9, 0x11, 0x01, 0xce, 0x8b, 0xa7, 0xae, 0xcb, 0xa1, 0xec, 0x5a, 0xc2,
	0xb0, 0x6e, 0x09, 0xdb, 0xd0, 0x53, 0xe2, 0x39, 0xc5, 0xec, 0x33, 0x14, 0xe3, 0xcf, 0x7d, 0x78,
	0xef, 0x22, 0x5b, 0x9e, 0xf0, 0x5c, 0xaa, 0x6c, 0x29, 0xf4, 0x17, 0xef, 0xcf, 0x3b, 0x30, 0x10,
	0x85, 0x50, 0xf3, 0x3b, 0xeb, 0xbc, 0xd5, 0x9a, 0xa9, 0xed, 0x9b, 0xd4, 0xfe, 0x19, 0x6c, 0x26,
	0xb2, 0xd0, 0x2a, 0xbb, 0x59, 0xe9, 0x4c, 0x16, 0xe6, 0xae, 0x34, 0x3e, 0xfe, 0x76, 0xc7, 0xad,
	0xee, 0xbe, 0x67, 0x87, 0x27, 0x66, 0x21, 0x6b, 0xef, 0xb0, 0xfb, 0x2b, 0x0f, 0x86, 0x76, 0x08,
	0xb9, 0xaf, 0xaf, 0x5a, 0xe4, 0x7f, 0xc0, 0x9a, 0x97, 0xaf, 0xda, 0x51, 0xbf, 0xe5, 0x68, 0x57,
	0xb7, 0xb5, 0x57, 0xae, 0xa0, 0x75, 0xf7, 0xab, 0xb4, 0x28, 0x67, 0xd2, 0x5d, 0xf1, 0x9c, 0x1a,
	0xff, 0xda, 0x83, 0xf7, 0x18, 0xbf, 0x7d, 0x0b, 0x50, 0x3e, 0x82, 0x11, 0x5f, 0x96, 0x79, 0xa6,
	0x57, 0xa9, 0x6b, 0x13, 0xb5, 0x01, 0x47, 0xd1, 0xb7, 0x0b, 0xcd, 0x97, 0xa5, 0xf5, 0xac, 0x36,
	0xc4, 0x9f, 0x79, 0xb0, 0xf5, 0x0e, 0xd9, 0x7c, 0x04, 0x23, 0x23, 0x61, 0x31, 0x9a, 0x8c, 0xac,
	0x0d, 0x9d, 0x37, 0x26, 0xcb, 0xff, 0xa0, 0xe6, 0xdf, 0x35, 0x87, 0x61, 0xbb, 0x01, 0x2a, 0x7e,
	0x4b, 0xfd, 0x2a, 0x60, 0x28, 0xc6, 0xff, 0xf6, 0x61, 0x78, 0x92, 0xaf, 0x2a, 0x6c, 0x7a, 0x5d,
	0xed, 0xe4, 0x21, 0x1a, 0x5b, 0x1e, 0xf6, 0xee, 0x7b, 0xf8, 0x66, 0x36, 0xe2, 0x95, 0x5d, 0x56,
	0xa6, 0xb7, 0x98, 0x2b, 0x3b, 0x69, 0x58, 0x77, 0x7a, 0x21, 0x34, 0x77, 0x8d, 0x96, 0x14, 0x57,
	0x9f, 0xc3, 0xba, 0x3e, 0x77, 0x60, 0x90, 0x66, 0x0a, 0xd7, 0x9b, 0xb2, 0xb2, 0x1a, 0xae, 0xaf,
	0x16, 0xbc, 0x14, 0xd4, 0x27, 0x7c, 0x66, 0x94, 0xf0, 0x08, 0x82, 0xd9, 0xf9, 0xd4, 0xb4, 0x89,
	0xf1, 0xf1, 0xa3, 0xce, 0x97, 0x9d, 0x7d, 0xac, 0x30, 0x9a, 0x49, 0x2f, 0x02, 0x03, 0x43, 0x45,
	0x57, 0x69, 0x7c, 0x11, 0x58, 0x7d, 0xdd, 0x8a, 0x26, 0x8d, 0x56, 0x14, 0xc1, 0xf0, 0x56, 0x64,
	0xf3, 0x85, 0x3d, 0xc4, 0x7c, 0xe6, 0xd4, 0xba, 0x29, 0x9e, 0x16, 0xa2, 0x8a, 0xb6, 0x68, 0xb0,
	0x61, 0x89, 0xff, 0xe9, 0xc3, 0x98, 0x89, 0x64, 0x5d, 0x28, 0x5d, 0xa8, 0xd3, 0x7d, 0xd7, 0x77,
	0xf7, 0xdd, 0xff, 0x52, 0xf3, 0xd8, 0x79, 0x82, 0xba, 0xf3, 0xb8, 0xf7, 0x86, 0xcd, 0x8c, 0x7b,
	0xef, 0x8d, 0xc1, 0xfd, 0xab, 0x0c, 0x76, 0xa9, 0xe1, 0xba, 0x4b, 0xad, 0x51, 0xdb, 0xf8, 0x9f,
	0x51, 0x8b, 0x60, 0x38, 0x3b, 0x9f, 0x5e, 0x56, 0x22, 0x75, 0x77, 0x36, 0xab, 0x86, 0x8f, 0x61,
	0x73, 0x2e, 0x65, 0x5a, 0x88, 0xaa, 0xfa, 0xe9, 0xf3, 0xd9, 0xf9, 0xd4, 0x9e, 0x7a, 0x6d, 0x23,
	0xfa, 0xab, 0x44, 0xe2, 0x10, 0x27, 0xb9, 0xd1, 0xe4, 0x27, 0xcd, 0x26, 0xdf, 0x62, 0x68, 0xf3,
	0x1e, 0x43, 0xbb, 0xb0, 0x51, 0x69, 0xae, 0xf4, 0x95, 0x7e, 0x15, 0x6d, 0x51, 0x72, 0xaf, 0xf5,
	0xf8, 0xcf, 0x1e, 0x0c, 0xae, 0xcc, 0x83, 0x0d, 0x1f, 0x84, 0x2a, 0x5b, 0x72, 0x75, 0xe7, 0x4a,
	0xd4, 0xaa, 0xcd, 0xb7, 0xa6, 0xdf, 0x7e, 0x6b, 0xba, 0xf3, 0xb4, 0xd7, 0x38, 0x4f, 0x43, 0x08,
	0x4a, 0x25, 0x6f, 0xdc, 0xe9, 0x89, 0xb2, 0x4b, 0xf9, 0x7e, 0x9d, 0xf2, 0x96, 0x9e, 0x41, 0x4d,
	0x4f, 0xfd, 0x6e, 0x1d, 0x36, 0xdf, 0xad, 0x74, 0xd6, 0x9b, 0x8c, 0xb0, 0xa5, 0xe9, 0xd4, 0xf8,
	0x0c, 0x36, 0x98, 0xc8, 0x39, 0xb6, 0x5f, 0xfc, 0xea, 0x73, 0x25, 0x97, 0xb6, 0xd7, 0x92, 0x8c,
	0x07, 0x94, 0x96, 0xe4, 0x72, 0xc0, 0x7c, 0x2d, 0xf1, 0x0b, 0x26, 0x0f, 0x5d, 0xaa, 0x18, 0xed,
	0xa3, 0x9f, 0x7f, 0xfe, 0x7a, 0xcf, 0xfb, 0xeb, 0xeb, 0x3d, 0xef, 0xef, 0xaf, 0xf7, 0xbc, 0xdf,
	0xfe, 0x63, 0xef, 0x4b, 0x30, 0x6e, 0xb0, 0xfb, 0x51, 0xf0, 0x34, 0xc9, 0xe4, 0xf5, 0xf1, 0x3c,
	0xd3, 0x8b, 0xd5, 0xcd, 0x61, 0x22, 0x97, 0x4f, 0x52, 0x91, 0x64, 0x37, 0x22, 0x4f, 0xa4, 0x2c,
	0x85, 0x7a, 0x62, 0x7e, 0x44, 0x9a, 0xcb, 0xef, 0xdc, 0xff, 0x35, 0xe9, 0x66, 0x40, 0x3f, 0x27,
	0x7d, 0xf0, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x82, 0x70, 0xbc, 0xb7, 0x68, 0x12, 0x00, 0x00,
}
